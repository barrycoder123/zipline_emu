/* sfcall.h: generated by interface compiler */

#ifndef __SFCALL_HEADER__
#define __SFCALL_HEADER__

#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <svdpi.h>


#ifdef __cplusplus
extern "C" {
#endif

static void Bv2Lvx(iscLv_t *lv, char *bv, int nbytes) {
  int i = 0;
  for (i = 0; nbytes >= 4; i++) {
    memcpy(&(lv[i].a), bv, 4);
    lv[i].b = 0;
    nbytes -= 4; bv += 4;
  }
  if (nbytes) {
    lv[i].a = 0;
    memcpy(&(lv[i].a), bv, nbytes);
    lv[i].b = 0;
  }
}
static void Lv2Bvx(char *bv, iscLv_t *lv, int nbytes) {
  int i = 0;
  for (i = 0; nbytes >= 4; i++) {
    unsigned v = lv[i].a & ~lv[i].b;
    memcpy(bv, &v, 4);
    nbytes -= 4; bv += 4;
  }
  if (nbytes) {
    unsigned v = lv[i].a & ~lv[i].b;
    memcpy(bv, &v, nbytes);
  }
}
static void AB2Lvx(iscLv_t *lv, unsigned *aval, unsigned *bval, int nwords) {
  int i = 0;
  for (i = 0; i < nwords; i++) {
    lv[i].a = aval[i];
    lv[i].b = bval[i];
  }
}
static void Lv2ABx(unsigned *aval, unsigned *bval, iscLv_t *lv, int nwords) {
  int i = 0;
  for (i = 0; i < nwords; i++) {
    aval[i] = lv[i].a;
    bval[i] = lv[i].b;
  }
}
/* Both Mbuf and bit array buffer in byte (8-bit) boundary */
static void Mbuf2Ba(char *mbuf, char *ba, int size) {
  int i;
  for (i = 0; i < size; i++) ba[i] = mbuf[i] & 1;
}
static void Ba2Mbuf(char *ba, char *mbuf, int size) {
  int i;
  for (i = 0; i < size; i++) mbuf[i] = ba[i] & 1;
}
static void Mbuf2La(char *mbuf, char *la, int size) {
  int i;
  for (i = 0; i < size; i++) la[i] = mbuf[i] & 3;
}
static void La2Mbuf(char *la, char *mbuf, int size) {
  int i;
  for (i = 0; i < size; i++) mbuf[i] = la[i] & 3;
}
/* Mbuf in byte (8-bit) boundary, while bv buffer in word (32-bit) bounary */
static void Mbuf2Bv(char *bv, char *mbuf, int nbytes, int width) {
  int ndestbytes = (width+31)/32 * 4;
  int nsrcbytes = (width+7)/8;
  char *destptr = bv;
  char *srcptr = mbuf;
  int cbytes = 0;
  while (cbytes < nbytes) {
    bzero((void *) destptr, ndestbytes);
    memcpy(destptr, srcptr, nsrcbytes);
    destptr += ndestbytes;
    srcptr += nsrcbytes;
    cbytes += nsrcbytes;
  }
}
static void Bv2Mbuf(char *mbuf, char *bv, int nbytes, int width) {
  int ndestbytes = (width+7)/8;
  int nsrcbytes = (width+31)/32 * 4;
  char *srcptr = bv;
  char *destptr = mbuf;
  int cbytes = 0;
  while (cbytes < nbytes) {
    memcpy(destptr, srcptr, ndestbytes);
    destptr += ndestbytes;
    srcptr += nsrcbytes;
    cbytes += ndestbytes;
  }
}

/* Mbuf in byte (8-bit) boundary, while lv buffer in word (32-bit) bounary */
static void Mbuf2Lv(iscLv_t *lv, char *mbuf, int nbytes, int width) {
  int srcWidth = (width+7)/8;
  int wbytes = 0;
  int cwidth = 4;
  char *srcptr = mbuf;
  int cbytes = 0;
  int i = 0;
  for (cbytes = 0, i = 0; cbytes < nbytes; cbytes += cwidth, i++) {
    cwidth = ((srcWidth - wbytes) >= 4) ? 4 : (srcWidth - wbytes);
    lv[i].a = 0; lv[i].b = 0;
    memcpy(&(lv[i].a), srcptr, cwidth);
    srcptr += cwidth;
    wbytes += cwidth;
    if (wbytes >= srcWidth) wbytes = 0;
  }
}
static void Lv2Mbuf(char *mbuf, iscLv_t *lv, int nbytes, int width) {
  int dstWidth = (width+7)/8;
  int wbytes = 0;
  int cwidth = 4;
  char *dstPtr = mbuf;
  int cbytes = 0;
  int i = 0;
  for (cbytes = 0, i = 0; cbytes < nbytes; cbytes += cwidth, i++) {
    cwidth = ((dstWidth - wbytes) >= 4) ? 4 : (dstWidth - wbytes);
    unsigned v = lv[i].a & ~lv[i].b;
    memcpy(dstPtr, &v, cwidth);
    dstPtr += cwidth;
    wbytes += cwidth;
    if (wbytes >= dstWidth) wbytes = 0;
  }
}


#ifdef __cplusplus
}
#endif

#endif // __SFCALL_HEADER__
