#
# Backend compiler script for ixcom 
#
set xecompileTarget [lindex $::argv 0]
set MCFlow [expr { [lsearch -exact -nocase $::argv "-mcBucket"] >= 0 } ? true : false]
if { $MCFlow } {
    set IXCOMbp true ;# Default
    if { [lsearch -exact -nocase $::argv "-bp"] >= 0 } { set IXCOMbp true }
    if { [lsearch -exact -nocase $::argv "-nobp"] >= 0 } { set IXCOMbp false }
    
    if { $IXCOMbp } {
        puts "Initiating MC flow (bp)"
        setModularCompile "IXCOMbp"
    } else {
        puts "Initiating MC flow"
        setModularCompile
    }
    if { [regexp -nocase -- {-mcBucket +([\w.]+)} $::argv dummy custBFile] && \
             $custBFile ni {1xua keepregs} } {
        puts "Using Custom bucket modules file: $custBFile"
        set ::MC(bucketModulesFile) $custBFile
    }
      
    # Not supported 
    if { [file exists "xc_work/qel/compile.qel"] || [file exists compile.qel] } {
        puts "MC-Flow: Ignoring compile.qel script"
    }
    set partitionArgIndex [lsearch $::argv "-partition"]
    if { $partitionArgIndex != -1 } {
        puts "MC-Flow: \"-partition\" is not supported yet"
        return -code error
    }
    # Hack to indicate import should be skipped
    set skipImport [file exists "xc_work/qel/skipImport.qel"]
    # Hack to indicate only import should run
    set importOnly [file exists "xc_work/qel/importOnly.qel"]

    if { [lsearch $argv "-rtldb"] != -1 } {
        puts "MC-Flow: \"-rtldb\" is not supported yet"
        return -code error
    }

    set importOptionsQel "importOptions.qel"
    if { [file exists $importOptionsQel] } {
        source $importOptionsQel
    } 

    # Get importOptions but do not execute designImport
    set ixcomImportScript "xc_work/qel/ixcomImport.qel"
    puts "Reading $ixcomImportScript"
    if { !$skipImport || !$IXCOMbp } {
        proc runImport {} { if { $::IXCOMbp } { eval diCompile -importOnly } }
        interp alias {} designImport {} runImport
        source $ixcomImportScript
        interp alias {} designImport {}
    }

    source [file join $env(QTHOME) etc qel ixcom_util.qel]

    if { $IXCOMbp } {
        if { $importOnly } { exit }
        set ixcPreDesignOptionsScript "xc_work/qel/ixcPreDesignOptions.qel"
        if {[file exists $ixcPreDesignOptionsScript]} {
           puts "Sourcing $ixcPreDesignOptionsScript"
           source $ixcPreDesignOptionsScript
        }             
        design hdldb xcva_top
    }
} else { ;# Regular and PPC flows

    # Source custom compile script from user if specified
    set compileQel "xc_work/qel/compile.qel"
    if { [file exists $compileQel] } {
        source $compileQel
        exit
    } else {
        if {[file exists compile.qel]} {
            source compile.qel
            exit
        }
    }
    
    source [file join $env(QTHOME) etc qel ixcom_util.qel]

    set partition ""
    set partitionArgIndex [lsearch $argv "-partition"]
    if { $partitionArgIndex != -1 } {
        set partition [lindex $argv [ expr $partitionArgIndex + 1 ]]
    }

    set skipImportScript "xc_work/$partition/qel/skipImport.qel"
    # Skip import if skipImportScript exists

    if { [file exists $skipImportScript] != 1} {
        if { $partition eq "" } {
           set ixcomImportScript "xc_work/qel/ixcomImport.qel"
        } else {
           set ixcomImportScript "xc_work/$partition/qel/ixcomImport.qel"
        }          
        set t [clock seconds]

        set importOptionsQel "importOptions.qel"
        if { [file exists $importOptionsQel] } {
           source $importOptionsQel
        } 
        # passing arguments by name
        handleImportArgs argc argv
        source $ixcomImportScript
        puts "IXCOMQEL> sourcing $ixcomImportScript took [expr [clock seconds] - $t]s"
    }

    set importOnly "xc_work/$partition/qel/importOnly.qel"
    if { [file exists $importOnly] == 1 } {
        exit
    }

    set ixcPreDesignOptionsScript "xc_work/qel/ixcPreDesignOptions.qel"    
    if {[file exists $ixcPreDesignOptionsScript]} {
        puts "Sourcing $ixcPreDesignOptionsScript"
        source $ixcPreDesignOptionsScript
    }      
    design hdldb xcva_top
}
if {[file exists xc_work/qel/ixcOptions.qel]} {
    source xc_work/qel/ixcOptions.qel
}
probeInternalNet -add xc_top.sdlEnable xc_top.tbcEnable xc_top.sdlHaltHwClk xc_top.hwClkDbg xc_top.hwClkDbgTime xc_top.hwClkEnable
if { $MCFlow } {
    if { [info exists diCompileFindOptions] || [string match $xecompileTarget {et3pass[12]}] } {
        set compileScript "diCompileFind"
        if { [info exists diCompileFindOptions] } { 
            append compileScript " $diCompileFindOptions" 
        }
        if { $xecompileTarget eq "et3pass1" } {
            append compileScript " -et3pass1"
        } else if { $xecompileTarget eq "et3pass2" } { 
            append compileScript " -et3pass2" 
        }
    } else {
        set compileScript "diCompile"
        if { $skipImport || $::IXCOMbp } {
            append compileScript " -skipImport "
        } elseif { $importOnly } {
            append compileScript " -importOnly "
        }
        if { $xecompileTarget eq "dbgPrepare" } {
            append compileScript " -dbgPrepareOnly"
        } elseif { $xecompileTarget eq "dbgPrepare2" } { 
            append compileScript " -dbgPreparePass2Only" 
        }
    }
} elseif { $xecompileTarget eq "precompile" } {
    set compileScript "precompile"
} elseif { $xecompileTarget eq "et3pass1" } {
    set compileScript "compileFind -et3pass1"
} elseif { $xecompileTarget eq "et3pass2" } {
    set compileScript "compileFind -et3pass2" 
} else {
    set compileScript "compile -names_crit"
}
set postCompileScript ""
# Make changes for UPF/CPF/1X features.
handleBackendArgs $argc $argv
# With et3pass1/2 we cannot afford to lose the emulator-config previously registered
if { $xecompileTarget ne "et3pass1" && $xecompileTarget ne "et3pass2"  && (($xecompileTarget ne "precompile") || ![checkEmulatorConfigUD]) && (($xecompileTarget eq "compile") || ![checkEmulatorConfigUD])} { 
    set defaultConfg [ file join $env(QTHOME) etc et3 ua_default.et3confg ]
    emulatorConfiguration -add "file $defaultConfg" "boards 0.0"
}
if {[file exists xc_work/nl/hot-swap.qel]} {
    source xc_work/nl/hot-swap.qel
}
if {[file exists xc_work/qel/mdx.qel]} {
    source xc_work/qel/mdx.qel
}
# Source compiler options script from user if specified
set compilerOptionsQel "xc_work/qel/compilerOptions.qel"
if { [file exists $compilerOptionsQel] } {
    source $compilerOptionsQel
} else {
    if {[file exists compilerOptions.qel]} {
	source compilerOptions.qel
    }
}
##############################
# Compile Find related section
set et3passTargets [string match $xecompileTarget {et3pass[12]}]
if { $MCFlow } {
    if { [info exists diCompileFindOptions] || $et3passTargets } {
        set compileScript "diCompileFind"
        if { [info exists diCompileFindOptions] } { 
            append compileScript " $diCompileFindOptions" 
        }
        if { $xecompileTarget eq "et3pass1" } {
            append compileScript " -et3pass1"
        } elseif { $xecompileTarget eq "et3pass2" } { 
            append compileScript " -et3pass2" 
        }
    }
    if { [info exists diCompileOptions] } { 
        append compileScript " $diCompileOptions" 
    }
} else {
    if { [info exists compileFindOptions] &&  $et3passTargets } {
        append compileScript " $compileFindOptions"
    } 
}
##############################
if {[info exists env(XE_DYNP)]} {
    compilerOption -add {visionMode DYNP}
} elseif  {[info exists env(UXE_DYNP)]} {
    compilerOption -add {visionMode DYNP}
}
if {[info exists env(XE_MINSTEP)]} {
  eval "compilerOption -add {minStep $env(XE_MINSTEP)}"
} elseif  {[info exists env(UXE_MINSTEP)]} {
  eval "compilerOption -add {minStep $env(UXE_MINSTEP)}"
}
checkEnvForHostSetup
set t [clock seconds]
eval $compileScript 
puts "IXCOMQEL> running $compileScript took [expr [clock seconds] - $t]s"
# Source post-Compile script
set postCompileQel "xc_work/qel/postCompile.qel"
if { [file exists $postCompileQel] } {
    source $postCompileQel
}
