<!--
/*************************************************************************
*
* Copyright © Microsoft Corporation. All rights reserved.
* Copyright © Broadcom Inc. All rights reserved.
* Licensed under the MIT License.
*
*************************************************************************/


!-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
  <meta name="generator" content="Adobe GoLive 5">
  <title>CR_CDDIP_SA</title>
</head>

<body>

<p>Generated on Wed Aug 15 06:10:32 2018</p>
<H1><a ID="Regs_Registers">CR_CDDIP_SA Regs Registers</a></H1>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="10%">Offset<br>(byte space)</th><th align="center" width="8%">Flags</th><th align="center" width="22%">Register Name </th><th align="center" width="60%">Description</th></tr>
  <tr><td align="center">0x0</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_revision_config" >CR_CDDIP_SA_revision_config</A></td><td>&nbsp;Revision read only register<br></td></tr>
  <tr><td align="center">0x4</td><td valign="top"> acc=RW</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_spare_config" >CR_CDDIP_SA_spare_config</A></td><td>&nbsp;Spare configuration register<br></td></tr>
  <tr><td align="center">0x8</td><td valign="top"> acc=RW</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_global_ctrl" >CR_CDDIP_SA_sa_global_ctrl</A></td><td>&nbsp;Global Control register<br></td></tr>
  <tr><td align="center">0xc</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_ctrl_ia_capability" >CR_CDDIP_SA_sa_ctrl_ia_capability</A></td><td>&nbsp;SA_CTRL Indirect Access Capability Register<br></td></tr>
  <tr><td align="center">0x10</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_ctrl_ia_status" >CR_CDDIP_SA_sa_ctrl_ia_status</A></td><td>&nbsp;SA_CTRL Indirect Access Status Register<br></td></tr>
  <tr><td align="center">0x14</td><td valign="top"> acc=CFG</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_ctrl_ia_wdata_part0" >CR_CDDIP_SA_sa_ctrl_ia_wdata_part0</A></td><td>&nbsp;SA_CTRL Indirect Access Write Data Register (SA_CTRL_t)<br></td></tr>
  <tr><td align="center">0x18</td><td valign="top"> acc=CFG</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_ctrl_ia_config" >CR_CDDIP_SA_sa_ctrl_ia_config</A></td><td>&nbsp;SA_CTRL Indirect Access Config Register<br></td></tr>
  <tr><td align="center">0x1c</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_ctrl_ia_rdata_part0" >CR_CDDIP_SA_sa_ctrl_ia_rdata_part0</A></td><td>&nbsp;SA_CTRL Indirect Access Read Data Register (SA_CTRL_t)<br></td></tr>
  <tr><td align="center">0x20</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_snapshot_ia_capability" >CR_CDDIP_SA_sa_snapshot_ia_capability</A></td><td>&nbsp;SA_SNAPSHOT Indirect Access Capability Register<br></td></tr>
  <tr><td align="center">0x24</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_snapshot_ia_status" >CR_CDDIP_SA_sa_snapshot_ia_status</A></td><td>&nbsp;SA_SNAPSHOT Indirect Access Status Register<br></td></tr>
  <tr><td align="center">0x28</td><td valign="top"> acc=CFG</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_snapshot_ia_wdata_part0" >CR_CDDIP_SA_sa_snapshot_ia_wdata_part0</A></td><td>&nbsp;SA_SNAPSHOT Indirect Access Write Data Register (SA_SNAPSHOT_Part1_t)<br></td></tr>
  <tr><td align="center">0x2c</td><td valign="top"> acc=CFG</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_snapshot_ia_wdata_part1" >CR_CDDIP_SA_sa_snapshot_ia_wdata_part1</A></td><td>&nbsp;SA_SNAPSHOT Indirect Access Write Data Register (SA_SNAPSHOT_Part0_t)<br></td></tr>
  <tr><td align="center">0x30</td><td valign="top"> acc=CFG</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_snapshot_ia_config" >CR_CDDIP_SA_sa_snapshot_ia_config</A></td><td>&nbsp;SA_SNAPSHOT Indirect Access Config Register<br></td></tr>
  <tr><td align="center">0x34</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_snapshot_ia_rdata_part0" >CR_CDDIP_SA_sa_snapshot_ia_rdata_part0</A></td><td>&nbsp;SA_SNAPSHOT Indirect Access Read Data Register (SA_SNAPSHOT_Part1_t)<br></td></tr>
  <tr><td align="center">0x38</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_snapshot_ia_rdata_part1" >CR_CDDIP_SA_sa_snapshot_ia_rdata_part1</A></td><td>&nbsp;SA_SNAPSHOT Indirect Access Read Data Register (SA_SNAPSHOT_Part0_t)<br></td></tr>
  <tr><td align="center">0x3c</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_count_ia_capability" >CR_CDDIP_SA_sa_count_ia_capability</A></td><td>&nbsp;SA_COUNT Indirect Access Capability Register<br></td></tr>
  <tr><td align="center">0x40</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_count_ia_status" >CR_CDDIP_SA_sa_count_ia_status</A></td><td>&nbsp;SA_COUNT Indirect Access Status Register<br></td></tr>
  <tr><td align="center">0x44</td><td valign="top"> acc=CFG</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_count_ia_wdata_part0" >CR_CDDIP_SA_sa_count_ia_wdata_part0</A></td><td>&nbsp;SA_COUNT Indirect Access Write Data Register (SA_COUNT_Part1_t)<br></td></tr>
  <tr><td align="center">0x48</td><td valign="top"> acc=CFG</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_count_ia_wdata_part1" >CR_CDDIP_SA_sa_count_ia_wdata_part1</A></td><td>&nbsp;SA_COUNT Indirect Access Write Data Register (SA_COUNT_Part0_t)<br></td></tr>
  <tr><td align="center">0x4c</td><td valign="top"> acc=CFG</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_count_ia_config" >CR_CDDIP_SA_sa_count_ia_config</A></td><td>&nbsp;SA_COUNT Indirect Access Config Register<br></td></tr>
  <tr><td align="center">0x50</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_count_ia_rdata_part0" >CR_CDDIP_SA_sa_count_ia_rdata_part0</A></td><td>&nbsp;SA_COUNT Indirect Access Read Data Register (SA_COUNT_Part1_t)<br></td></tr>
  <tr><td align="center">0x54</td><td valign="top"> acc=RO</td><td>&nbsp;<A HREF="#CR_CDDIP_SA_sa_count_ia_rdata_part1" >CR_CDDIP_SA_sa_count_ia_rdata_part1</A></td><td>&nbsp;SA_COUNT Indirect Access Read Data Register (SA_COUNT_Part0_t)<br></td></tr>
</table>
<p>Flag legend: acc=access</p><p></p>
<p>
  <b><a ID="CR_CDDIP_SA_revision_config">CR_CDDIP_SA_revision_config - Revision read only register</a></b><br>
  Offset (byte space) = 32'h0<br>
  Verilog Macro Address = `CR_CDDIP_SA_REVISION_CONFIG<br>
  Reset Value = 32'bxxxxxxxx_xxxxxxxx_xxxxxxxx_00000000<br>
  Access = RO (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:08</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">07:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;revid</td><td align="left">Revision control register.<br>Connect to TIE cells in order to change<br>via 1 layer metal spin.<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_spare_config">CR_CDDIP_SA_spare_config - Spare configuration register</a></b><br>
  Offset (byte space) = 32'h4<br>
  Verilog Macro Address = `CR_CDDIP_SA_SPARE_CONFIG<br>
  Reset Value = 32'h0000_0000<br>
  Access = RW (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;spare</td><td align="left">Spare control register<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_global_ctrl">CR_CDDIP_SA_sa_global_ctrl - Global Control register</a></b><br>
  Offset (byte space) = 32'h8<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_GLOBAL_CTRL<br>
  Reset Value = 32'h0000_0000<br>
  Access = RW (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:02</td><td valign="top"></td><td align="left" valign="top">&nbsp;spare</td><td align="left">Spare control register<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">01</td><td valign="top"></td><td align="left" valign="top">&nbsp;sa_snap</td><td align="left">Snapshot all SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">00</td><td valign="top"></td><td align="left" valign="top">&nbsp;sa_clear_live</td><td align="left">Clear all SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_ctrl_ia_capability">CR_CDDIP_SA_sa_ctrl_ia_capability - SA_CTRL Indirect Access Capability Register</a></b><br>
  Offset (byte space) = 32'hc<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_CTRL_IA_CAPABILITY<br>
  Reset Value = 32'hxxxx_xxxx<br>
  Access = RO (32-bit only)<br>
</p>
The SA_CTRL indirect access capability register is used to give<br>the status of all the indirect access operation capabilites<br>that can be handled;<br>Refer to SA_CTRL Config register for descriptions of the indirect<br>access operations.<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:28</td><td valign="top"></td><td align="left" valign="top">&nbsp;mem_type</td><td align="left">MEM_TYPE<br>0 = <i>SPRAM</i><br>SPRAM memory<br>1 = <i>SRFRAM</i><br>SRFRAM memory<br>2 = <i>REG</i><br>REG memory<br>3 = <i>TCAM</i><br>TCAM memory<br>4 = <i>MEM_TYPE_4</i><br>Reserved memory type<br>5 = <i>MEM_TYPE_5</i><br>Reserved memory type<br>6 = <i>MEM_TYPE_6</i><br>Reserved memory type<br>7 = <i>MEM_TYPE_7</i><br>Reserved memory type<br>8 = <i>MEM_TYPE_8</i><br>Reserved memory type<br>9 = <i>MEM_TYPE_9</i><br>Reserved memory type<br>10 = <i>MEM_TYPE_10</i><br>Reserved memory type<br>11 = <i>MEM_TYPE_11</i><br>Reserved memory type<br>12 = <i>MEM_TYPE_12</i><br>Reserved memory type<br>13 = <i>MEM_TYPE_13</i><br>Reserved memory type<br>14 = <i>MEM_TYPE_14</i><br>Reserved memory type<br>15 = <i>MEM_TYPE_15</i><br>Reserved memory type<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">27:16</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">15</td><td valign="top"></td><td align="left" valign="top">&nbsp;ack_error</td><td align="left">1 = ack_error operation is supported; 0 = ack_error operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">14</td><td valign="top"></td><td align="left" valign="top">&nbsp;sim_tmo</td><td align="left">1 = sim_tmo operation is supported; 0 = sim_tmo operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">13:10</td><td valign="top"></td><td align="left" valign="top">&nbsp;reserved_op</td><td align="left">reserved_op are reserved bits that don't map to any operations supported<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">09</td><td valign="top"></td><td align="left" valign="top">&nbsp;compare</td><td align="left">1 = compare operation is supported; 0 = compare operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">08</td><td valign="top"></td><td align="left" valign="top">&nbsp;set_init_start</td><td align="left">1 = set_init_start operation is supported; 0 = set_init_start operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">07</td><td valign="top"></td><td align="left" valign="top">&nbsp;initialize_inc</td><td align="left">1 = initialize_inc operation is supported; 0 = initialize_inc operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">06</td><td valign="top"></td><td align="left" valign="top">&nbsp;initialize</td><td align="left">1 = initialze operation is supported; 0 = initialize operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05</td><td valign="top"></td><td align="left" valign="top">&nbsp;reset</td><td align="left">1 = reset operation is supported; 0 = reset operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">04</td><td valign="top"></td><td align="left" valign="top">&nbsp;disabled</td><td align="left">1 = disabled operation is supported; 0 = disabled operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">03</td><td valign="top"></td><td align="left" valign="top">&nbsp;enable</td><td align="left">1 = enable operation is supported; 0 = enable operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">02</td><td valign="top"></td><td align="left" valign="top">&nbsp;write</td><td align="left">1 = write operation is supported; 0 = write operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">01</td><td valign="top"></td><td align="left" valign="top">&nbsp;read</td><td align="left">1 = read operation is supported; 0 = read operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">00</td><td valign="top"></td><td align="left" valign="top">&nbsp;nop</td><td align="left">1 = nop operation is supported; 0 = nop operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_ctrl_ia_status">CR_CDDIP_SA_sa_ctrl_ia_status - SA_CTRL Indirect Access Status Register</a></b><br>
  Offset (byte space) = 32'h10<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_CTRL_IA_STATUS<br>
  Reset Value = 32'b00000000_xxxxxxxx_xxxxxxxx_xx111111<br>
  Access = RO (32-bit only)<br>
</p>
The SA_CTRL indirect access status register is used to provide<br>information about SA_CTRL indirect accesses.<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:29</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;code</td><td align="left">FIELD ACCESS: RO<br><br>Indicates the status of the indirect access. Commands should only be<br>issued when this status indicates READY. Errors are signalled with<br>a status that is not READY and not BUSY. Errors must be acknowledged<br>before any other commands will be accepted.<br>0 = <i>READY</i><br>Ready for access.<br>1 = <i>BUSY</i><br>Busy with current command.<br>2 = <i>TMO</i><br>Timed out on current command.<br>3 = <i>OVR</i><br>Command overrun, command issued when machine not ready.<br>4 = <i>NXM</i><br>Command attempted access to illegal offset.<br>5 = <i>UOP</i><br>Unsupported opcode. Command opcode is not supported.<br>7 = <i>PDN</i><br>Memory is in power-down state.<br>Reset value is <i>READY</i>.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">28:24</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;datawords</td><td align="left">FIELD ACCESS: RO<br><br>Indicates the number of registers in the indirect access data<br>register array minus one.<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">23:06</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05:00</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;addr</td><td align="left">FIELD ACCESS: RO<br><br>While the access controller is in the init state then this will<br>read zero (representing a memory with a single entry) which is how<br>the memory will behave. After an enable command is issued and the<br>controller enters the ready state then this will be 63<br>indicating a memory with 64 entries.<br>Reset value is <i>63</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p>Flag legend: acc=access</p><p></p>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_ctrl_ia_wdata_part0">CR_CDDIP_SA_sa_ctrl_ia_wdata_part0 - SA_CTRL Indirect Access Write Data Register (SA_CTRL_t)</a></b><br>
  Offset (byte space) = 32'h14<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_CTRL_IA_WDATA_PART0<br>
  Reset Value = 32'h0000_0000<br>
  Access = CFG (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:10</td><td valign="top"></td><td align="left" valign="top">&nbsp;spare</td><td align="left">Spare control register<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">09:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;sa_event_sel</td><td align="left">Event Select<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_ctrl_ia_config">CR_CDDIP_SA_sa_ctrl_ia_config - SA_CTRL Indirect Access Config Register</a></b><br>
  Offset (byte space) = 32'h18<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_CTRL_IA_CONFIG<br>
  Reset Value = 32'b0000xxxx_xxxxxxxx_xxxxxxxx_xx000000<br>
  Access = CFG (32-bit only)<br>
</p>
The SA_CTRL indirect access config register is used to initiate<br>read/write accesses to the SA_CTRL table. The data to be written<br>is provided via the SA_CTRL_IA_WData register(s). Read<br>data is returned via the SA_CTRL_IA_RData register(s).<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:28</td><td valign="top"></td><td align="left" valign="top">&nbsp;op</td><td align="left">The operation requested of the table.<br>0 = <i>NOP</i><br>Do nothing.<br>1 = <i>READ</i><br>Read Table.<br>2 = <i>WRITE</i><br>Write Table.<br>3 = <i>ENABLE</i><br>The memory intializes in a low power state. It needs to be taken<br>out of this state before reads and writes are enabled. Execute this<br>operation to exit the power-down state.<br>Note that when in this state the underlying table "appears" as a<br>single entry table to the hardware and the software. As a convenience<br>this single entry can be written directly via the write data registers<br>without the need to effect the config/status command/response<br>access protocol. As such any writes to those registers while the memory<br>is disabled are reflected directly to the hardware.<br>4 = <i>DISABLED</i><br>To put the memory back into its power-down state execute this.<br>The state of the memory can be examined by reading the status<br>register which returns with an addr field of zero when the<br>memory is disabled. Note that in the disabled mode, the table<br>behaves exactly as if it has a single entry.<br>5 = <i>RESET</i><br>Reset each table entry to that defined by the RDB definition. This<br>command requires only a single register write.<br>6 = <i>INITIALIZE</i><br>Init each table entry to the value provided by the write data<br>register(s) from a start entry up to a maximum entry number provided<br>in the addr field of the indirect access configuration register. Use<br>a SET_INIT_START command to define the starting entry.<br>7 = <i>INITIALIZE_INC</i><br>Similar to initialize but increment the write data for each<br>successive entry.<br>This command increments some N least significant bits of the<br>table entry. N may be zero in which case this command behaves the<br>same as the INITIALIZE command.<br>In the general case N may be determined by setting the write data<br>to all ones and commanding INITIALIZE_INC with an addr field of 1.<br>N is the number of bits that are zero in entry 1.<br>8 = <i>SET_INI_START</i><br>Set the start point for an initialization to the addr field of<br>the indirect access configuration register. To initialize a table<br>from entry A to entry B, first issue SET_INIT_START with a<br>command address of A, then issue INITIALIZE with a command address<br>of B.<br>9 = <i>COMPARE</i><br>TCAM ONLY. Compare Operation.<br>14 = <i>SIM_TMO</i><br>Simulate a timeout condition for software testing.<br>15 = <i>ACK_ERROR</i><br>Acknowledge and clear error conditions.<br>Reset value is <i>NOP</i>.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">27:06</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;addr</td><td align="left">Indicates the address of the entry to be read or written. The<br>SA_CTRL table has 64 entries.<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_ctrl_ia_rdata_part0">CR_CDDIP_SA_sa_ctrl_ia_rdata_part0 - SA_CTRL Indirect Access Read Data Register (SA_CTRL_t)</a></b><br>
  Offset (byte space) = 32'h1c<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_CTRL_IA_RDATA_PART0<br>
  Reset Value = 32'h0000_0000<br>
  Access = RO (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:10</td><td valign="top"></td><td align="left" valign="top">&nbsp;spare</td><td align="left">Spare control register<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">09:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;sa_event_sel</td><td align="left">Event Select<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_snapshot_ia_capability">CR_CDDIP_SA_sa_snapshot_ia_capability - SA_SNAPSHOT Indirect Access Capability Register</a></b><br>
  Offset (byte space) = 32'h20<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_SNAPSHOT_IA_CAPABILITY<br>
  Reset Value = 32'hxxxx_xxxx<br>
  Access = RO (32-bit only)<br>
</p>
The SA_SNAPSHOT indirect access capability register is used to give<br>the status of all the indirect access operation capabilites<br>that can be handled;<br>Refer to SA_SNAPSHOT Config register for descriptions of the indirect<br>access operations.<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:28</td><td valign="top"></td><td align="left" valign="top">&nbsp;mem_type</td><td align="left">MEM_TYPE<br>0 = <i>SPRAM</i><br>SPRAM memory<br>1 = <i>SRFRAM</i><br>SRFRAM memory<br>2 = <i>REG</i><br>REG memory<br>3 = <i>TCAM</i><br>TCAM memory<br>4 = <i>MEM_TYPE_4</i><br>Reserved memory type<br>5 = <i>MEM_TYPE_5</i><br>Reserved memory type<br>6 = <i>MEM_TYPE_6</i><br>Reserved memory type<br>7 = <i>MEM_TYPE_7</i><br>Reserved memory type<br>8 = <i>MEM_TYPE_8</i><br>Reserved memory type<br>9 = <i>MEM_TYPE_9</i><br>Reserved memory type<br>10 = <i>MEM_TYPE_10</i><br>Reserved memory type<br>11 = <i>MEM_TYPE_11</i><br>Reserved memory type<br>12 = <i>MEM_TYPE_12</i><br>Reserved memory type<br>13 = <i>MEM_TYPE_13</i><br>Reserved memory type<br>14 = <i>MEM_TYPE_14</i><br>Reserved memory type<br>15 = <i>MEM_TYPE_15</i><br>Reserved memory type<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">27:16</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">15</td><td valign="top"></td><td align="left" valign="top">&nbsp;ack_error</td><td align="left">1 = ack_error operation is supported; 0 = ack_error operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">14</td><td valign="top"></td><td align="left" valign="top">&nbsp;sim_tmo</td><td align="left">1 = sim_tmo operation is supported; 0 = sim_tmo operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">13:10</td><td valign="top"></td><td align="left" valign="top">&nbsp;reserved_op</td><td align="left">reserved_op are reserved bits that don't map to any operations supported<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">09</td><td valign="top"></td><td align="left" valign="top">&nbsp;compare</td><td align="left">1 = compare operation is supported; 0 = compare operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">08</td><td valign="top"></td><td align="left" valign="top">&nbsp;set_init_start</td><td align="left">1 = set_init_start operation is supported; 0 = set_init_start operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">07</td><td valign="top"></td><td align="left" valign="top">&nbsp;initialize_inc</td><td align="left">1 = initialize_inc operation is supported; 0 = initialize_inc operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">06</td><td valign="top"></td><td align="left" valign="top">&nbsp;initialize</td><td align="left">1 = initialze operation is supported; 0 = initialize operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05</td><td valign="top"></td><td align="left" valign="top">&nbsp;reset</td><td align="left">1 = reset operation is supported; 0 = reset operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">04</td><td valign="top"></td><td align="left" valign="top">&nbsp;disabled</td><td align="left">1 = disabled operation is supported; 0 = disabled operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">03</td><td valign="top"></td><td align="left" valign="top">&nbsp;enable</td><td align="left">1 = enable operation is supported; 0 = enable operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">02</td><td valign="top"></td><td align="left" valign="top">&nbsp;write</td><td align="left">1 = write operation is supported; 0 = write operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">01</td><td valign="top"></td><td align="left" valign="top">&nbsp;read</td><td align="left">1 = read operation is supported; 0 = read operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">00</td><td valign="top"></td><td align="left" valign="top">&nbsp;nop</td><td align="left">1 = nop operation is supported; 0 = nop operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_snapshot_ia_status">CR_CDDIP_SA_sa_snapshot_ia_status - SA_SNAPSHOT Indirect Access Status Register</a></b><br>
  Offset (byte space) = 32'h24<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_SNAPSHOT_IA_STATUS<br>
  Reset Value = 32'b00000001_xxxxxxxx_xxxxxxxx_xx111111<br>
  Access = RO (32-bit only)<br>
</p>
The SA_SNAPSHOT indirect access status register is used to provide<br>information about SA_SNAPSHOT indirect accesses.<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:29</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;code</td><td align="left">FIELD ACCESS: RO<br><br>Indicates the status of the indirect access. Commands should only be<br>issued when this status indicates READY. Errors are signalled with<br>a status that is not READY and not BUSY. Errors must be acknowledged<br>before any other commands will be accepted.<br>0 = <i>READY</i><br>Ready for access.<br>1 = <i>BUSY</i><br>Busy with current command.<br>2 = <i>TMO</i><br>Timed out on current command.<br>3 = <i>OVR</i><br>Command overrun, command issued when machine not ready.<br>4 = <i>NXM</i><br>Command attempted access to illegal offset.<br>5 = <i>UOP</i><br>Unsupported opcode. Command opcode is not supported.<br>7 = <i>PDN</i><br>Memory is in power-down state.<br>Reset value is <i>READY</i>.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">28:24</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;datawords</td><td align="left">FIELD ACCESS: RO<br><br>Indicates the number of registers in the indirect access data<br>register array minus one.<br>Reset value is <i>1</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">23:06</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05:00</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;addr</td><td align="left">FIELD ACCESS: RO<br><br>While the access controller is in the init state then this will<br>read zero (representing a memory with a single entry) which is how<br>the memory will behave. After an enable command is issued and the<br>controller enters the ready state then this will be 63<br>indicating a memory with 64 entries.<br>Reset value is <i>63</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p>Flag legend: acc=access</p><p></p>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_snapshot_ia_wdata_part0">CR_CDDIP_SA_sa_snapshot_ia_wdata_part0 - SA_SNAPSHOT Indirect Access Write Data Register (SA_SNAPSHOT_Part1_t)</a></b><br>
  Offset (byte space) = 32'h28<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_SNAPSHOT_IA_WDATA_PART0<br>
  Reset Value = 32'h0000_0000<br>
  Access = CFG (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:18</td><td valign="top"></td><td align="left" valign="top">&nbsp;unused</td><td align="left">unused<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">17:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;upper</td><td align="left">Snapshot view of SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_snapshot_ia_wdata_part1">CR_CDDIP_SA_sa_snapshot_ia_wdata_part1 - SA_SNAPSHOT Indirect Access Write Data Register (SA_SNAPSHOT_Part0_t)</a></b><br>
  Offset (byte space) = 32'h2c<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_SNAPSHOT_IA_WDATA_PART1<br>
  Reset Value = 32'h0000_0000<br>
  Access = CFG (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;lower</td><td align="left">Snapshot view of SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_snapshot_ia_config">CR_CDDIP_SA_sa_snapshot_ia_config - SA_SNAPSHOT Indirect Access Config Register</a></b><br>
  Offset (byte space) = 32'h30<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_SNAPSHOT_IA_CONFIG<br>
  Reset Value = 32'b0000xxxx_xxxxxxxx_xxxxxxxx_xx000000<br>
  Access = CFG (32-bit only)<br>
</p>
The SA_SNAPSHOT indirect access config register is used to initiate<br>read/write accesses to the SA_SNAPSHOT table. The data to be written<br>is provided via the SA_SNAPSHOT_IA_WData register(s). Read<br>data is returned via the SA_SNAPSHOT_IA_RData register(s).<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:28</td><td valign="top"></td><td align="left" valign="top">&nbsp;op</td><td align="left">The operation requested of the table.<br>0 = <i>NOP</i><br>Do nothing.<br>1 = <i>READ</i><br>Read Table.<br>2 = <i>WRITE</i><br>Write Table.<br>3 = <i>ENABLE</i><br>The memory intializes in a low power state. It needs to be taken<br>out of this state before reads and writes are enabled. Execute this<br>operation to exit the power-down state.<br>Note that when in this state the underlying table "appears" as a<br>single entry table to the hardware and the software. As a convenience<br>this single entry can be written directly via the write data registers<br>without the need to effect the config/status command/response<br>access protocol. As such any writes to those registers while the memory<br>is disabled are reflected directly to the hardware.<br>4 = <i>DISABLED</i><br>To put the memory back into its power-down state execute this.<br>The state of the memory can be examined by reading the status<br>register which returns with an addr field of zero when the<br>memory is disabled. Note that in the disabled mode, the table<br>behaves exactly as if it has a single entry.<br>5 = <i>RESET</i><br>Reset each table entry to that defined by the RDB definition. This<br>command requires only a single register write.<br>6 = <i>INITIALIZE</i><br>Init each table entry to the value provided by the write data<br>register(s) from a start entry up to a maximum entry number provided<br>in the addr field of the indirect access configuration register. Use<br>a SET_INIT_START command to define the starting entry.<br>7 = <i>INITIALIZE_INC</i><br>Similar to initialize but increment the write data for each<br>successive entry.<br>This command increments some N least significant bits of the<br>table entry. N may be zero in which case this command behaves the<br>same as the INITIALIZE command.<br>In the general case N may be determined by setting the write data<br>to all ones and commanding INITIALIZE_INC with an addr field of 1.<br>N is the number of bits that are zero in entry 1.<br>8 = <i>SET_INI_START</i><br>Set the start point for an initialization to the addr field of<br>the indirect access configuration register. To initialize a table<br>from entry A to entry B, first issue SET_INIT_START with a<br>command address of A, then issue INITIALIZE with a command address<br>of B.<br>9 = <i>COMPARE</i><br>TCAM ONLY. Compare Operation.<br>14 = <i>SIM_TMO</i><br>Simulate a timeout condition for software testing.<br>15 = <i>ACK_ERROR</i><br>Acknowledge and clear error conditions.<br>Reset value is <i>NOP</i>.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">27:06</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;addr</td><td align="left">Indicates the address of the entry to be read or written. The<br>SA_SNAPSHOT table has 64 entries.<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_snapshot_ia_rdata_part0">CR_CDDIP_SA_sa_snapshot_ia_rdata_part0 - SA_SNAPSHOT Indirect Access Read Data Register (SA_SNAPSHOT_Part1_t)</a></b><br>
  Offset (byte space) = 32'h34<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_SNAPSHOT_IA_RDATA_PART0<br>
  Reset Value = 32'h0000_0000<br>
  Access = RO (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:18</td><td valign="top"></td><td align="left" valign="top">&nbsp;unused</td><td align="left">unused<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">17:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;upper</td><td align="left">Snapshot view of SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_snapshot_ia_rdata_part1">CR_CDDIP_SA_sa_snapshot_ia_rdata_part1 - SA_SNAPSHOT Indirect Access Read Data Register (SA_SNAPSHOT_Part0_t)</a></b><br>
  Offset (byte space) = 32'h38<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_SNAPSHOT_IA_RDATA_PART1<br>
  Reset Value = 32'h0000_0000<br>
  Access = RO (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;lower</td><td align="left">Snapshot view of SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_count_ia_capability">CR_CDDIP_SA_sa_count_ia_capability - SA_COUNT Indirect Access Capability Register</a></b><br>
  Offset (byte space) = 32'h3c<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_COUNT_IA_CAPABILITY<br>
  Reset Value = 32'hxxxx_xxxx<br>
  Access = RO (32-bit only)<br>
</p>
The SA_COUNT indirect access capability register is used to give<br>the status of all the indirect access operation capabilites<br>that can be handled;<br>Refer to SA_COUNT Config register for descriptions of the indirect<br>access operations.<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:28</td><td valign="top"></td><td align="left" valign="top">&nbsp;mem_type</td><td align="left">MEM_TYPE<br>0 = <i>SPRAM</i><br>SPRAM memory<br>1 = <i>SRFRAM</i><br>SRFRAM memory<br>2 = <i>REG</i><br>REG memory<br>3 = <i>TCAM</i><br>TCAM memory<br>4 = <i>MEM_TYPE_4</i><br>Reserved memory type<br>5 = <i>MEM_TYPE_5</i><br>Reserved memory type<br>6 = <i>MEM_TYPE_6</i><br>Reserved memory type<br>7 = <i>MEM_TYPE_7</i><br>Reserved memory type<br>8 = <i>MEM_TYPE_8</i><br>Reserved memory type<br>9 = <i>MEM_TYPE_9</i><br>Reserved memory type<br>10 = <i>MEM_TYPE_10</i><br>Reserved memory type<br>11 = <i>MEM_TYPE_11</i><br>Reserved memory type<br>12 = <i>MEM_TYPE_12</i><br>Reserved memory type<br>13 = <i>MEM_TYPE_13</i><br>Reserved memory type<br>14 = <i>MEM_TYPE_14</i><br>Reserved memory type<br>15 = <i>MEM_TYPE_15</i><br>Reserved memory type<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">27:16</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">15</td><td valign="top"></td><td align="left" valign="top">&nbsp;ack_error</td><td align="left">1 = ack_error operation is supported; 0 = ack_error operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">14</td><td valign="top"></td><td align="left" valign="top">&nbsp;sim_tmo</td><td align="left">1 = sim_tmo operation is supported; 0 = sim_tmo operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">13:10</td><td valign="top"></td><td align="left" valign="top">&nbsp;reserved_op</td><td align="left">reserved_op are reserved bits that don't map to any operations supported<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">09</td><td valign="top"></td><td align="left" valign="top">&nbsp;compare</td><td align="left">1 = compare operation is supported; 0 = compare operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">08</td><td valign="top"></td><td align="left" valign="top">&nbsp;set_init_start</td><td align="left">1 = set_init_start operation is supported; 0 = set_init_start operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">07</td><td valign="top"></td><td align="left" valign="top">&nbsp;initialize_inc</td><td align="left">1 = initialize_inc operation is supported; 0 = initialize_inc operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">06</td><td valign="top"></td><td align="left" valign="top">&nbsp;initialize</td><td align="left">1 = initialze operation is supported; 0 = initialize operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05</td><td valign="top"></td><td align="left" valign="top">&nbsp;reset</td><td align="left">1 = reset operation is supported; 0 = reset operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">04</td><td valign="top"></td><td align="left" valign="top">&nbsp;disabled</td><td align="left">1 = disabled operation is supported; 0 = disabled operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">03</td><td valign="top"></td><td align="left" valign="top">&nbsp;enable</td><td align="left">1 = enable operation is supported; 0 = enable operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">02</td><td valign="top"></td><td align="left" valign="top">&nbsp;write</td><td align="left">1 = write operation is supported; 0 = write operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">01</td><td valign="top"></td><td align="left" valign="top">&nbsp;read</td><td align="left">1 = read operation is supported; 0 = read operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">00</td><td valign="top"></td><td align="left" valign="top">&nbsp;nop</td><td align="left">1 = nop operation is supported; 0 = nop operation is NOT supported;<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_count_ia_status">CR_CDDIP_SA_sa_count_ia_status - SA_COUNT Indirect Access Status Register</a></b><br>
  Offset (byte space) = 32'h40<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_COUNT_IA_STATUS<br>
  Reset Value = 32'b00000001_xxxxxxxx_xxxxxxxx_xx111111<br>
  Access = RO (32-bit only)<br>
</p>
The SA_COUNT indirect access status register is used to provide<br>information about SA_COUNT indirect accesses.<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:29</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;code</td><td align="left">FIELD ACCESS: RO<br><br>Indicates the status of the indirect access. Commands should only be<br>issued when this status indicates READY. Errors are signalled with<br>a status that is not READY and not BUSY. Errors must be acknowledged<br>before any other commands will be accepted.<br>0 = <i>READY</i><br>Ready for access.<br>1 = <i>BUSY</i><br>Busy with current command.<br>2 = <i>TMO</i><br>Timed out on current command.<br>3 = <i>OVR</i><br>Command overrun, command issued when machine not ready.<br>4 = <i>NXM</i><br>Command attempted access to illegal offset.<br>5 = <i>UOP</i><br>Unsupported opcode. Command opcode is not supported.<br>7 = <i>PDN</i><br>Memory is in power-down state.<br>Reset value is <i>READY</i>.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">28:24</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;datawords</td><td align="left">FIELD ACCESS: RO<br><br>Indicates the number of registers in the indirect access data<br>register array minus one.<br>Reset value is <i>1</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">23:06</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05:00</td><td valign="top"> acc=RO</td><td align="left" valign="top">&nbsp;addr</td><td align="left">FIELD ACCESS: RO<br><br>While the access controller is in the init state then this will<br>read zero (representing a memory with a single entry) which is how<br>the memory will behave. After an enable command is issued and the<br>controller enters the ready state then this will be 63<br>indicating a memory with 64 entries.<br>Reset value is <i>63</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p>Flag legend: acc=access</p><p></p>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_count_ia_wdata_part0">CR_CDDIP_SA_sa_count_ia_wdata_part0 - SA_COUNT Indirect Access Write Data Register (SA_COUNT_Part1_t)</a></b><br>
  Offset (byte space) = 32'h44<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_COUNT_IA_WDATA_PART0<br>
  Reset Value = 32'h0000_0000<br>
  Access = CFG (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:18</td><td valign="top"></td><td align="left" valign="top">&nbsp;unused</td><td align="left">unused<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">17:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;upper</td><td align="left">live view of SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_count_ia_wdata_part1">CR_CDDIP_SA_sa_count_ia_wdata_part1 - SA_COUNT Indirect Access Write Data Register (SA_COUNT_Part0_t)</a></b><br>
  Offset (byte space) = 32'h48<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_COUNT_IA_WDATA_PART1<br>
  Reset Value = 32'h0000_0000<br>
  Access = CFG (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;lower</td><td align="left">live view of SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_count_ia_config">CR_CDDIP_SA_sa_count_ia_config - SA_COUNT Indirect Access Config Register</a></b><br>
  Offset (byte space) = 32'h4c<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_COUNT_IA_CONFIG<br>
  Reset Value = 32'b0000xxxx_xxxxxxxx_xxxxxxxx_xx000000<br>
  Access = CFG (32-bit only)<br>
</p>
The SA_COUNT indirect access config register is used to initiate<br>read/write accesses to the SA_COUNT table. The data to be written<br>is provided via the SA_COUNT_IA_WData register(s). Read<br>data is returned via the SA_COUNT_IA_RData register(s).<br><br><table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:28</td><td valign="top"></td><td align="left" valign="top">&nbsp;op</td><td align="left">The operation requested of the table.<br>0 = <i>NOP</i><br>Do nothing.<br>1 = <i>READ</i><br>Read Table.<br>2 = <i>WRITE</i><br>Write Table.<br>3 = <i>ENABLE</i><br>The memory intializes in a low power state. It needs to be taken<br>out of this state before reads and writes are enabled. Execute this<br>operation to exit the power-down state.<br>Note that when in this state the underlying table "appears" as a<br>single entry table to the hardware and the software. As a convenience<br>this single entry can be written directly via the write data registers<br>without the need to effect the config/status command/response<br>access protocol. As such any writes to those registers while the memory<br>is disabled are reflected directly to the hardware.<br>4 = <i>DISABLED</i><br>To put the memory back into its power-down state execute this.<br>The state of the memory can be examined by reading the status<br>register which returns with an addr field of zero when the<br>memory is disabled. Note that in the disabled mode, the table<br>behaves exactly as if it has a single entry.<br>5 = <i>RESET</i><br>Reset each table entry to that defined by the RDB definition. This<br>command requires only a single register write.<br>6 = <i>INITIALIZE</i><br>Init each table entry to the value provided by the write data<br>register(s) from a start entry up to a maximum entry number provided<br>in the addr field of the indirect access configuration register. Use<br>a SET_INIT_START command to define the starting entry.<br>7 = <i>INITIALIZE_INC</i><br>Similar to initialize but increment the write data for each<br>successive entry.<br>This command increments some N least significant bits of the<br>table entry. N may be zero in which case this command behaves the<br>same as the INITIALIZE command.<br>In the general case N may be determined by setting the write data<br>to all ones and commanding INITIALIZE_INC with an addr field of 1.<br>N is the number of bits that are zero in entry 1.<br>8 = <i>SET_INI_START</i><br>Set the start point for an initialization to the addr field of<br>the indirect access configuration register. To initialize a table<br>from entry A to entry B, first issue SET_INIT_START with a<br>command address of A, then issue INITIALIZE with a command address<br>of B.<br>9 = <i>COMPARE</i><br>TCAM ONLY. Compare Operation.<br>14 = <i>SIM_TMO</i><br>Simulate a timeout condition for software testing.<br>15 = <i>ACK_ERROR</i><br>Acknowledge and clear error conditions.<br>Reset value is <i>NOP</i>.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">27:06</td><td valign="top"></td><td align="left" valign="top">&nbsp;Reserved</td><td align="left">Reserved bits must be written with 0.  A read returns an unknown value.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">05:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;addr</td><td align="left">Indicates the address of the entry to be read or written. The<br>SA_COUNT table has 64 entries.<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_count_ia_rdata_part0">CR_CDDIP_SA_sa_count_ia_rdata_part0 - SA_COUNT Indirect Access Read Data Register (SA_COUNT_Part1_t)</a></b><br>
  Offset (byte space) = 32'h50<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_COUNT_IA_RDATA_PART0<br>
  Reset Value = 32'h0000_0000<br>
  Access = RO (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:18</td><td valign="top"></td><td align="left" valign="top">&nbsp;unused</td><td align="left">unused<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
  <tr><td align="center" valign="top">17:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;upper</td><td align="left">live view of SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
<p>
  <b><a ID="CR_CDDIP_SA_sa_count_ia_rdata_part1">CR_CDDIP_SA_sa_count_ia_rdata_part1 - SA_COUNT Indirect Access Read Data Register (SA_COUNT_Part0_t)</a></b><br>
  Offset (byte space) = 32'h54<br>
  Verilog Macro Address = `CR_CDDIP_SA_SA_COUNT_IA_RDATA_PART1<br>
  Reset Value = 32'h0000_0000<br>
  Access = RO (32-bit only)<br>
</p>
<table border=1 align="center" width="100%" cellpadding="0">
  <tr bgcolor="#C0CFF0"><th align="center" width="5%">Bit Field</th><th align="center" width="8%">Flags</th><th align="center" width="25%">Field Name</th><th align="center" width="52%">Description</th><th align="center" width="10%">Properties/Attributes</th></tr>
  <tr><td align="center" valign="top">31:00</td><td valign="top"></td><td align="left" valign="top">&nbsp;lower</td><td align="left">live view of SA counters<br>Reset value is <i>0</i> decimal.<br></td><td align="left">&nbsp;</td></tr>
</table>
<p><A HREF="#Regs_Registers">Return to CR_CDDIP_SA Regs Table</A></p>
</body>
</html>
